package fr.guiguilechat.jcelechat.model.sde.types.skill;

import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;
import fr.guiguilechat.jcelechat.model.sde.Attribute;
import fr.guiguilechat.jcelechat.model.sde.IMetaCategory;
import fr.guiguilechat.jcelechat.model.sde.IMetaGroup;
import fr.guiguilechat.jcelechat.model.sde.annotations.DefaultIntValue;
import fr.guiguilechat.jcelechat.model.sde.annotations.DefaultRealValue;
import fr.guiguilechat.jcelechat.model.sde.annotations.HighIsGood;
import fr.guiguilechat.jcelechat.model.sde.annotations.Stackable;
import fr.guiguilechat.jcelechat.model.sde.attributes.AccessDifficultyBonusAbsolutePercent;
import fr.guiguilechat.jcelechat.model.sde.attributes.CanNotBeTrainedOnTrial;
import fr.guiguilechat.jcelechat.model.sde.attributes.ConsumptionQuantityBonus;
import fr.guiguilechat.jcelechat.model.sde.attributes.DamageCloudChanceReduction;
import fr.guiguilechat.jcelechat.model.sde.attributes.GasDecompressionEfficiencyBonus;
import fr.guiguilechat.jcelechat.model.sde.attributes.IceHarvestCycleBonus;
import fr.guiguilechat.jcelechat.model.sde.attributes.IsSkillIObsolete;
import fr.guiguilechat.jcelechat.model.sde.attributes.MiningAmountBonus;
import fr.guiguilechat.jcelechat.model.sde.attributes.MiningCritBonusYieldBonus;
import fr.guiguilechat.jcelechat.model.sde.attributes.MiningCritChanceBonus;
import fr.guiguilechat.jcelechat.model.sde.attributes.MiningUpgradeCPUReductionBonus;
import fr.guiguilechat.jcelechat.model.sde.attributes.PrimaryAttribute;
import fr.guiguilechat.jcelechat.model.sde.attributes.ReactionSlotBonus;
import fr.guiguilechat.jcelechat.model.sde.attributes.ReactionTimeBonus;
import fr.guiguilechat.jcelechat.model.sde.attributes.RefiningYieldMutator;
import fr.guiguilechat.jcelechat.model.sde.attributes.RequiredSkill1;
import fr.guiguilechat.jcelechat.model.sde.attributes.RequiredSkill1Level;
import fr.guiguilechat.jcelechat.model.sde.attributes.RequiredSkill2;
import fr.guiguilechat.jcelechat.model.sde.attributes.RequiredSkill2Level;
import fr.guiguilechat.jcelechat.model.sde.attributes.RequiredSkill3;
import fr.guiguilechat.jcelechat.model.sde.attributes.RequiredSkill3Level;
import fr.guiguilechat.jcelechat.model.sde.attributes.SecondaryAttribute;
import fr.guiguilechat.jcelechat.model.sde.attributes.SkillLevel;
import fr.guiguilechat.jcelechat.model.sde.attributes.SkillTimeConstant;
import fr.guiguilechat.jcelechat.model.sde.types.Skill;
import org.yaml.snakeyaml.LoaderOptions;
import org.yaml.snakeyaml.Yaml;

public class ResourceProcessing
    extends Skill
{
    @HighIsGood(true)
    @Stackable(true)
    @DefaultIntValue(0)
    public int gasdecompressionefficiencybonus;
    /**
     * Bonus to chance of opening a container (for skills).
     */
    @HighIsGood(true)
    @Stackable(true)
    @DefaultIntValue(0)
    public int accessdifficultybonusabsolutepercent;
    /**
     * If set to 1 then this skill can not be trained on accounts that are marked as Alpha Clone. Any other value (although you should probably use 0) will result in all accounts being able to train this skill.
     */
    @HighIsGood(true)
    @Stackable(true)
    @DefaultIntValue(1)
    public int cannotbetrainedontrial;
    /**
     * 
     */
    @HighIsGood(true)
    @Stackable(true)
    @DefaultIntValue(0)
    public int consumptionquantitybonus;
    /**
     * Autogenerated skill attribute, damageCloudChanceReduction
     */
    @HighIsGood(true)
    @Stackable(true)
    @DefaultIntValue(0)
    public int damagecloudchancereduction;
    /**
     * 
     */
    @HighIsGood(true)
    @Stackable(true)
    @DefaultRealValue(0.0)
    public double iceharvestcyclebonus;
    /**
     * When set True, skill can no longer be injected or trained. Characters will be reimbursed with free SP for any obsolete skills in the skill queue upon logon.
     */
    @HighIsGood(true)
    @Stackable(true)
    @DefaultIntValue(0)
    public int isskilliobsolete;
    /**
     * Autogenerated skill attribute, miningAmountBonus
     */
    @HighIsGood(true)
    @Stackable(true)
    @DefaultIntValue(0)
    public int miningamountbonus;
    @HighIsGood(true)
    @Stackable(true)
    @DefaultIntValue(0)
    public int miningcritbonusyieldbonus;
    @HighIsGood(true)
    @Stackable(true)
    @DefaultIntValue(0)
    public int miningcritchancebonus;
    /**
     * CPU Penalty Reduction
     */
    @HighIsGood(true)
    @Stackable(true)
    @DefaultIntValue(0)
    public int miningupgradecpureductionbonus;
    /**
     * Increase number of available/simultaneous reaction slots
     */
    @HighIsGood(true)
    @Stackable(true)
    @DefaultIntValue(0)
    public int reactionslotbonus;
    /**
     * Skill attribute that reduces time for reactions
     *  jobs
     */
    @HighIsGood(true)
    @Stackable(true)
    @DefaultIntValue(0)
    public int reactiontimebonus;
    /**
     * Autogenerated skill attribute, refiningYieldMutator
     */
    @HighIsGood(true)
    @Stackable(true)
    @DefaultIntValue(0)
    public int refiningyieldmutator;
    /**
     * The type ID of the skill that is required.
     */
    @HighIsGood(true)
    @Stackable(true)
    @DefaultIntValue(0)
    public int requiredskill2;
    /**
     * Required skill level for skill 2
     */
    @HighIsGood(true)
    @Stackable(true)
    @DefaultIntValue(0)
    public int requiredskill2level;
    /**
     * The type ID of the skill that is required.
     */
    @HighIsGood(true)
    @Stackable(true)
    @DefaultIntValue(0)
    public int requiredskill3;
    /**
     * Required skill level for skill 3
     */
    @HighIsGood(true)
    @Stackable(true)
    @DefaultIntValue(0)
    public int requiredskill3level;
    /**
     * Level of skill
     */
    @HighIsGood(true)
    @Stackable(true)
    @DefaultIntValue(0)
    public int skilllevel;
    public static final Set<Attribute> ATTRIBUTES = Collections.unmodifiableSet(new LinkedHashSet<>(Arrays.asList(new Attribute[] {MiningCritChanceBonus.INSTANCE, MiningCritBonusYieldBonus.INSTANCE, ReactionTimeBonus.INSTANCE, ReactionSlotBonus.INSTANCE, AccessDifficultyBonusAbsolutePercent.INSTANCE, IceHarvestCycleBonus.INSTANCE, IsSkillIObsolete.INSTANCE, MiningAmountBonus.INSTANCE, SkillTimeConstant.INSTANCE, PrimaryAttribute.INSTANCE, ConsumptionQuantityBonus.INSTANCE, SecondaryAttribute.INSTANCE, RequiredSkill1Level.INSTANCE, RequiredSkill2Level.INSTANCE, RequiredSkill1 .INSTANCE, RequiredSkill2 .INSTANCE, CanNotBeTrainedOnTrial.INSTANCE, RequiredSkill3Level.INSTANCE, SkillLevel.INSTANCE, RequiredSkill3 .INSTANCE, RefiningYieldMutator.INSTANCE, GasDecompressionEfficiencyBonus.INSTANCE, DamageCloudChanceReduction.INSTANCE, MiningUpgradeCPUReductionBonus.INSTANCE })));
    public static final ResourceProcessing.MetaGroup METAGROUP = new ResourceProcessing.MetaGroup();

    @Override
    public Number valueSet(Attribute attribute) {
        switch (attribute.getId()) {
            case  3260 :
            {
                return gasdecompressionefficiencybonus;
            }
            case  1772 :
            {
                return accessdifficultybonusabsolutepercent;
            }
            case  1047 :
            {
                return cannotbetrainedontrial;
            }
            case  885 :
            {
                return consumptionquantitybonus;
            }
            case  543 :
            {
                return damagecloudchancereduction;
            }
            case  780 :
            {
                return iceharvestcyclebonus;
            }
            case  2450 :
            {
                return isskilliobsolete;
            }
            case  434 :
            {
                return miningamountbonus;
            }
            case  6050 :
            {
                return miningcritbonusyieldbonus;
            }
            case  6049 :
            {
                return miningcritchancebonus;
            }
            case  927 :
            {
                return miningupgradecpureductionbonus;
            }
            case  2661 :
            {
                return reactionslotbonus;
            }
            case  2660 :
            {
                return reactiontimebonus;
            }
            case  379 :
            {
                return refiningyieldmutator;
            }
            case  183 :
            {
                return requiredskill2;
            }
            case  278 :
            {
                return requiredskill2level;
            }
            case  184 :
            {
                return requiredskill3;
            }
            case  279 :
            {
                return requiredskill3level;
            }
            case  280 :
            {
                return skilllevel;
            }
            default:
            {
                return super.valueSet((attribute));
            }
        }
    }

    @Override
    public Set<Attribute> getAttributes() {
        return ATTRIBUTES;
    }

    @Override
    public IMetaGroup<ResourceProcessing> getGroup() {
        return METAGROUP;
    }

    public static class MetaGroup
        implements IMetaGroup<ResourceProcessing>
    {
        public static final String RESOURCE_PATH = "SDE/types/skill/ResourceProcessing.yaml";
        private Map<Integer, ResourceProcessing> cache = (null);

        @Override
        public IMetaCategory<? super ResourceProcessing> category() {
            return Skill.METACAT;
        }

        @Override
        public int getGroupId() {
            return  1218;
        }

        @Override
        public String getName() {
            return "ResourceProcessing";
        }

        @Override
        public synchronized Map<Integer, ResourceProcessing> load() {
            if (cache == null) {
                try(final InputStreamReader reader = new InputStreamReader(ResourceProcessing.MetaGroup.class.getClassLoader().getResourceAsStream((RESOURCE_PATH)))) {
                    LoaderOptions options = new LoaderOptions();
                    options.setCodePointLimit(Integer.MAX_VALUE);
                    cache = new Yaml(options).loadAs(reader, (Container.class)).types;
                } catch (final Exception exception) {
                    throw new UnsupportedOperationException("catch this", exception);
                }
            }
            return Collections.unmodifiableMap(cache);
        }

        private static class Container {
            public LinkedHashMap<Integer, ResourceProcessing> types;
        }
    }
}
